function _nix_attr_names () {
    # prefix with 'top' as we let 'top = $defexpr' in NIX_FILE, where
    # 'builtins.attrNames $prefixed_path' is being run
    local prefixed_path=top${1:+.$1}
    local defexpr="$2"
    nix-instantiate --eval - <<NIX_FILE 2> /dev/null | tr '"[]' ' '
                let
                  top_gen = $defexpr;
                  # --file arguments can be a lambda producing a record too
                  top = if builtins.typeOf top_gen == "lambda" then top_gen {} else top_gen ;
                in
                  builtins.attrNames $prefixed_path
NIX_FILE
}

function _nix_attr_paths () {

    # The unnamed top context to look up attribute names
    local defexpr="$1"

    # The known valid part of the attribute path, eg. 'nixpkgs', if the
    # currently typed word is 'nixpkgs.mp'
    local attr_path=""
    if [[ -z ${cur/*.*/} ]]; then
        attr_path=${cur%.*}
    fi

    # Get all the attribute names in $attr_path
    local -a packages=($(_nix_attr_names "$attr_path" "$defexpr"))

    # Prefix all matches with "${attr_path}."
    local word_list=${packages[*]/#/${attr_path:+${attr_path}.}}
    ## Generate the completion list and match against the current word
    COMPREPLY=( $(compgen -W "${word_list}" ${cur}))
}


function _parse () {
    # -f[:*]:action:[*]action
    # [*]-f:action:action
    # [n]:action
    # :[*]action
    local -A options=()
    local -a arguments=("command")

    # Parse the spec
    local spec="$1"
    local -A groups
    local cur_group=""
    local split group excludes
    while [[ "$spec" ]]; do
        group=""
        excludes=""
        case "$spec" in
            # *-\>*)
            #     # check if we're using -> syntax
            #     ;;
            +)
                shift
                cur_group="$1"
            ;;
            \(*\)-*)
                excludes=${spec%%\)*}
                excludes=${excludes:1}"#"
                spec="${spec#*\)}"
                ;&
            -*)
                # Split on first :
                local -a split=(${spec/:/ })
                local flag=${split[0]}
                if [[ "$cur_group" ]]; then
                    # Add the flag to the glob group
                    groups[$cur_group]+=${groups[$cur_group]:+|}$flag
                fi
                # Internal representation [group#][excludes#];
                options[$flag]="$excludes:${split[1]}"
                ;;
            :*|\*:*)
 #              echo Adding argument $spec
                arguments+=("$spec")
                ;;
        esac
        shift
        spec="$1"
    done
    echo -- finished parsing spec >> ~/log/nix
    echo arguments: ${arguments[*]} >> ~/log/nix
    echo options: ${!options[*]} ${options[*]} >> ~/log/nix
    echo groups: ${!groups[*]} ${groups[*]} >> ~/log/nix


    echo -- Parse words >> ~/log/nix
    # Use the parsed spec to handle the input
    # opt_arg queue
    local -a opt_queue=()
    local -a used_options=()
    local current_option=""
    local excluded_options=""
    # The list of completors corresponding to each word
    completors=()
    line=()
    local word
    for word in ${words[*]} ""; do
        if [[ "${opt_queue[*]}" ]]; then
            # Consume an option argument
            echo consume option queue: $word ${opt_queue[0]} >> ~/log/nix
            line+=("$word")
            local separator=${opt_args["$current_option"]:+:}
            opt_args["$current_option"]+=$separator"${word//:/\\:}"

            local action="${opt_queue[0]}"
            if [[ "$action" == \** ]]; then
                completors+=(${action#\*})
            else
                completors+=(${action})
                opt_queue=(${opt_queue[*]:1})
            fi
        elif [[ "$word" == -* ]]; then
            echo Consume an option: $word ${options["$word"]} >> ~/log/nix
            completors+=("$word")
            local -a actions=(${options["$word"]//:/ })
            # Check if actions contains an exclusion pattern
            if [[ ${actions[0]} == *\# ]]; then
                local prefix="${excluded_options:+|}"
                echo "$word's exclusion group:" ${actions[0]} >> ~/log/nix
                excluded_options+="$prefix${actions[0]#\#*}"
                actions=${actions[*]:1}
            fi
            if [[ "${actions[*]}" ]]; then
                current_option="$word"
                # Add to the option argument queue
                opt_queue=(${actions[*]})
            fi
            echo option queue: ${opt_queue[*]} >> ~/log/nix
        else
            # Consume a regular argument
            echo Consume a regular argument: $word >> ~/log/nix
            line+=("$word")
            echo Adding completor: ${arguments[0]} >> ~/log/nix
            # Always add argument completors, even if empty
            local action="${arguments[0]}"
            echo action: $action >> ~/log/nix
            if [[ "$action" == \*:* ]]; then
                    completors+=("${action#\*:}")
                    # Don't shift $arguments when the action is repeatable
            else
                completors+=("${action#:}")
                arguments=(${arguments[*]:1})
                echo rest of arguments: ${arguments[*]} >> ~/log/nix
            fi
        fi
    done

    echo -- Finished parsing words: ${completors[*]} >> ~/log/nix

    local completor=${completors[$cword]}
    echo completor: $completor >> ~/log/nix

    case "$completor" in
        -\>*)
            state="${completor#->}"
            return 1
            ;;
        -*)
            ## Complete options
            echo excluded_options $excluded_options >> ~/log/nix
            COMPREPLY=($(compgen -W "${!options[*]}" -X "*($excluded_options)" -- "$cur"))
            return 0
            ;;
        *)
            "$completor" &> ~/log/nix
            return 0
    esac
}

function _nix_legacy () {
    local cur prev words cword
    # Setup current word, previous word, words and index of current word in
    # words (cword)
    _init_completion -n = || return

    echo number ${#words[*]} >> ~/log/nix
    echo cword $cword >> ~/log/nix
    echo ${words[*]} >> ~/log/nix

    local -a nix_boilerplate_opts=('--help' '--version')

    local nix_repair='--repair';

    local nix_search_path_args='-I:->file'

    # Misc Nix options accepted by nixos-rebuild
    local nix_common_nixos_rebuild=(
        {--verbose,-v} {--no-build-output,-Q}
        {--max-jobs,-j}':->empty' '--cores'
        '(--keep-going|-k)'{--keep-going,-k} {--keep-failed,-K}
        '--fallback' '--show-trace'
        '--option:->nixoption:->nixoptionvalue'
        ${nix_repair})

    # Used in: nix-build, nix-env, nix-instantiate, nix-shell
    local -a nix_common_opts=(
        ${nix_common_nixos_rebuild[*]}
            $_nix_search_path_args
            {--attr,-A}':->attr_path' {--expr,-E}
            '--arg:->empty:->empty' '--argstr:->empty:->empty'
            '--max-silent-time:->empty'
            '--timeout:->empty'
            '--readonly-mode'
            '--log-type:->log-type')

    local state context
    local -a line
    local -A opt_args
    case "${words[0]}" in
        nix-build)
            local -a nix_build_opts=(
                '--drv-link:->empty' '--add-drv-link'
                '--no-out-link'
                {--out-link,-o}':->empty')
            _parse '*:->file' ${nix_common_opts[*]} \
                   ${nix_boilerplate_opts[*]} \
                   ${nix_build_opts[*]} && return 0
            ;;
        nix-shell)
            local -a nix_shell_opts=(
                '--command:->command'
                '--exclude:->regex'
                '--pure'
                '(--packages|-p|shell)'{--packages,-p}':->package_attr_path')
            _parse '*:->file' ${nix_common_opts[*]} \
                   + boiler \
                   ${nix_boilerplate_opts[*]} \
                   + shell \
                   ${nix_shell_opts[*]} && return 0
            ;;
    esac

    echo state: $state >> ~/log/nix
    echo line: ${line[*]} >> ~/log/nix
    echo opt_args: ${!opt_args[*]} ${opt_args[*]} >> ~/log/nix
    echo >> ~/log/nix

    case "$state" in
        attr_path)
            local defexpr_path=""
            if [[ ${line[1]} ]]; then
                defexpr_path="import ${line[1]} {}"
            elif [[ -e shell.nix && $command_name == nix-shell ]]; then
                defexpr_path=shell.nix
            elif [[ -e default.nix ]]; then
                defexpr_path=default.nix
            fi
            echo defexpr: "$defexpr_path" >> ~/log/nix
            _nix_attr_paths "$defexpr_path"
            return 0
            ;;
        package_attr_path)
            _nix_attr_paths "import <nixpkgs>"
            return 0
            ;;
        file)
            COMPREPLY=($(compgen -f $cur))
            ;;
        *)
            ;;

    esac
    return 1
}
# Set _nix_build to handle completion for nix-build
complete -F _nix_legacy nix-build nix-shell

function _nix () {
    local cur prev words cword
    # Setup current word, previous word, words and index of current word in
    # words (cword)
    _init_completion -n = || return

    local -a commands=(add-to-store build cat-nar cat-store copy copy-sigs dump-path edit eval hash-file hash-path log ls-nar ls-store optimise-store path-info repl run search show-config show-derivation sign-paths to-base16 to-base32 to-base64 verify why-depends
                           )

    local word
    for word in ${words[*]}; do
        case $word in
            run|build|eval)

                if [[ $cur == $word ]]; then
                    return 0
                fi

                local defexpr='{ '
                local -a nix_path=(${NIX_PATH/:/ })
                for i in ${nix_path[*]}; do
                    if [[ -z ${i/*=*/} ]]; then
                        # nixos-config isn't useful for completion
                        [[ ${i%=*} == nixos-config ]] && continue
                        defexpr+="${i/=/= import } {}; "
                    fi
                done
                local defexpr+=' }'

                _nix_attr_paths "$defexpr"
                return 0
                ;;
            *)
                # If word matches a command return
                if [[ "${commands[*]%$word}" != "${commands[*]}" ]]; then
                    return 0
                fi
        esac
    done

    COMPREPLY=( $(compgen -W "${commands[*]}" ${cur}))
}
complete -F _nix nix
