function _nix_attr_names () {
    # prefix with 'top' as we let 'top = $defexpr' in NIX_FILE, where
    # 'builtins.attrNames $prefixed_path' is being run
    local prefixed_path=top${1:+.$1}
    local defexpr="$2"
    nix-instantiate --eval - <<NIX_FILE 2> /dev/null | tr '"[]' ' '
                let
                  top_gen = $defexpr;
                  # --file arguments can be a lambda producing a record too
                  top = if builtins.typeOf top_gen == "lambda" then top_gen {} else top_gen ;
                in
                  builtins.attrNames $prefixed_path
NIX_FILE
}

function _nix_attr_paths () {

    # The unnamed top context to look up attribute names
    local defexpr="$1"

    # The known valid part of the attribute path, eg. 'nixpkgs', if the
    # currently typed word is 'nixpkgs.mp'
    local attr_path=""
    if [[ -z ${cur/*.*/} ]]; then
        attr_path=${cur%.*}
    fi

    # Get all the attribute names in $attr_path
    local -a packages=($(_nix_attr_names "$attr_path" "$defexpr"))

    # Prefix all matches with "${attr_path}."
    local word_list=${packages[*]/#/${attr_path:+${attr_path}.}}
    ## Generate the completion list and match against the current word
    COMPREPLY=( $(compgen -W "${word_list}" ${cur}))
}


function _parse () {
    # -f[:*]:action:[*]action
    # [*]-f:action:action
    # [n]:action
    # :[*]action
    local -A options=()
    local -a arguments=("command")

    # Parse the spec
    local spec="$1"
    while [[ "$spec" ]]; do
        case "$spec" in
            # *-\>*)
            #     # check if we're using -> syntax
            #     ;;
            -*)
                # Split on first :
                local -a split=(${spec/:/ })
                local flag="${split[0]}"
 #              echo Adding option ${spec[0]} ${spec[1]}
                options[$flag]="${split[1]}"
                ;;
            :*)
 #              echo Adding argument $spec
                arguments+=("$spec")
                ;;
        esac
        shift
        spec="$1"
    done
    echo -- finished parsing spec >> ~/log/nix
    echo arguments: ${arguments[*]} >> ~/log/nix


    echo -- Parse words >> ~/log/nix
    # Use the parsed spec to handle the input
    # opt_arg queue
    local -a opt_queue=()
    local -a used_options=()
    local current_option=""
    # The list of completors corresponding to each word
    completors=()
    line=()
    local word
    for word in ${words[*]}; do
        if [[ "${opt_queue[*]}" ]]; then
            # Consume an option argument
            echo consume option queue: $word ${opt_queue[0]} >> ~/log/nix
            line+=("$word")
            completors+=(${opt_queue[0]})
            opt_queue=(${opt_queue[*]:1})
        elif [[ "$word" == -* ]]; then
            echo Consume an option: $word  >> ~/log/nix
            completors+=("$word")
            # Add to the option argument queue
            opt_queue=(${options["$word"]//:/ })
            echo option queue: ${opt_queue[*]} >> ~/log/nix
        else
            # Consume a regular argument
            echo Consume a regular argument: $word >> ~/log/nix
            line+=("$word")
            echo Adding completor: ${arguments[0]} >> ~/log/nix
            # Always add argument completors, even if empty
            completors+=("${arguments[0]}")
            arguments=(${arguments[*]:1})
        fi
    done

    echo -- Finished parsing words: ${completors[*]} >> ~/log/nix

    local completor=${completors[$cword]}
    echo completor $completor >> ~/log/nix

    case "$completor" in
        -\>*)
            state="${completor#->}"
            return 1
            ;;
        -*)
            ## Complete options
            return 0
            ;;
        *)
            "$completor" &> ~/log/nix
            return 0
    esac
}

function _nix_build () {
    local cur prev words cword
    # Setup current word, previous word, words and index of current word in
    # words (cword)
    _init_completion -n = || return

    echo number ${#words[*]} >> ~/log/nix
    echo cword $cword >> ~/log/nix
    echo ${words[*]} >> ~/log/nix

    local state
    local -a line
    _parse "-A:->attr_path" && return 0

    echo state $state >> ~/log/nix
    echo line ${line[*]} >> ~/log/nix

    case "$state" in
        attr_path)
            local defexpr_path=""
            if [[ ${line[1]} ]]; then
                defexpr_path="import ${line[1]}"
            elif [[ -e shell.nix && $command_name == nix-shell ]]; then
                defexpr_path=shell.nix
            elif [[ -e default.nix ]]; then
                defexpr_path=default.nix
            fi
            _nix_attr_paths "$defexpr_path"
            ;;
    esac
    return 1
}
# Set _nix_build to handle completion for nix-build
complete -F _nix_build nix-build

function _nix () {
    local cur prev words cword
    # Setup current word, previous word, words and index of current word in
    # words (cword)
    _init_completion -n = || return

    local -a commands=(add-to-store build cat-nar cat-store copy copy-sigs dump-path edit eval hash-file hash-path log ls-nar ls-store optimise-store path-info repl run search show-config show-derivation sign-paths to-base16 to-base32 to-base64 verify why-depends
                           )

    local word
    for word in ${words[*]}; do
        case $word in
            run|build|eval)

                if [[ $cur == $word ]]; then
                    return 0
                fi

                local defexpr='{ '
                local -a nix_path=(${NIX_PATH/:/ })
                for i in ${nix_path[*]}; do
                    if [[ -z ${i/*=*/} ]]; then
                        # nixos-config isn't useful for completion
                        [[ ${i%=*} == nixos-config ]] && continue
                        defexpr+="${i/=/= import } {}; "
                    fi
                done
                local defexpr+=' }'

                _nix_attr_paths "$defexpr"
                return 0
                ;;
            *)
                # If word matches a command return
                if [[ "${commands[*]%$word}" != "${commands[*]}" ]]; then
                    return 0
                fi
        esac
    done

    COMPREPLY=( $(compgen -W "${commands[*]}" ${cur}))
}
complete -F _nix nix
