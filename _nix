function _nix_attr_names () {
    # prefix with 'top' as we let 'top = $defexpr' in NIX_FILE, where
    # 'builtins.attrNames $prefixed_path' is being run
    local prefixed_path=top${1:+.$1}
    local defexpr="$2"
    nix-instantiate --eval - <<NIX_FILE 2> /dev/null | tr '"[]' ' '
                let
                  top_gen = $defexpr;
                  # --file arguments can be a lambda producing a record too
                  top = if builtins.typeOf top_gen == "lambda" then top_gen {} else top_gen ;
                in
                  builtins.attrNames $prefixed_path
NIX_FILE
}

function _nix_attr_paths () {

    # The unnamed top context to look up attribute names
    local defexpr="$1"

    # The known valid part of the attribute path, eg. 'nixpkgs', if the
    # currently typed word is 'nixpkgs.mp'
    local attr_path=""
    if [[ -z ${cur/*.*/} ]]; then
        attr_path=${cur%.*}
    fi

    # Get all the attribute names in $attr_path
    local -a packages=($(_nix_attr_names "$attr_path" "$defexpr"))

    # Prefix all matches with "${attr_path}."
    local word_list=${packages[*]/#/${attr_path:+${attr_path}.}}
    ## Generate the completion list and match against the current word
    COMPREPLY=( $(compgen -W "${word_list}" ${cur}))
}


function _parse () {
    # -f[:*]:action:[*]action
    # [*]-f:action:action
    # [n]:action
    # :[*]action
    local -A options=()
    local -a arguments=("command")

    # Parse the spec
    local spec="$1"
    local -A groups
    local cur_group=""
    local split group excludes
    while [[ "$spec" ]]; do
        group=""
        excludes=""
        case "$spec" in
            # *-\>*)
            #     # check if we're using -> syntax
            #     ;;
            +)
                shift
                cur_group="$1"
            ;;
            \(*\)-*)
                excludes=${spec%%\)*}
                excludes=${excludes:1}"#"
                spec="${spec#*\)}"
                ;&
            -*)
                # Split on first :
                local -a split=(${spec/:/ })
                local flag=${split[0]}
                if [[ "$cur_group" ]]; then
                    # Add the flag to the glob group
                    groups[$cur_group]+=${groups[$cur_group]:+|}$flag
                fi
                # Internal representation [group#][excludes#];
                options[$flag]="$excludes:${split[1]}"
                ;;
            :*|\*:*)
 #              echo Adding argument $spec
                arguments+=("$spec")
                ;;
        esac
        shift
        spec="$1"
    done
    echo -- finished parsing spec >> ~/log/nix
    echo arguments: ${arguments[*]} >> ~/log/nix
    echo options: ${!options[*]} ${options[*]} >> ~/log/nix
    echo groups: ${!groups[*]} ${groups[*]} >> ~/log/nix


    echo -- Parse words >> ~/log/nix
    # Use the parsed spec to handle the input
    # opt_arg queue
    local -a opt_queue=()
    local -a used_options=()
    local current_option=""
    local excluded_options=""
    # The list of completors corresponding to each word
    completors=()
    line=()
    local word
    for word in ${words[*]} ""; do
        if [[ "${opt_queue[*]}" ]]; then
            # Consume an option argument
            echo consume option queue: $word ${opt_queue[0]} >> ~/log/nix
            line+=("$word")
            local separator=${opt_args["$current_option"]:+:}
            opt_args["$current_option"]+=$separator"${word//:/\\:}"

            local action="${opt_queue[0]}"
            if [[ "$action" == \** ]]; then
                completors+=(${action#\*})
            else
                completors+=(${action})
                opt_queue=(${opt_queue[*]:1})
            fi
        elif [[ "$word" == -* ]]; then
            echo Consume an option: $word ${options["$word"]} >> ~/log/nix
            completors+=("$word")
            local -a actions=(${options["$word"]//:/ })
            # Check if actions contains an exclusion pattern
            if [[ ${actions[0]} == *\# ]]; then
                local prefix="${excluded_options:+|}"
                excluded_options+="$prefix${actions[0]:0:-1}"
                echo "$word's exclusion group:" "$prefix${actions[0]:0:-1}" >> ~/log/nix
                actions=(${actions[*]:1})
            fi
            if [[ "${actions[*]}" ]]; then
                current_option="$word"
                # Add to the option argument queue
                opt_queue=(${actions[*]})
            fi
        else
            # Consume a regular argument
            echo Consume a regular argument: $word >> ~/log/nix
            line+=("$word")
            echo Adding completor: ${arguments[0]} >> ~/log/nix
            # Always add argument completors, even if empty
            local action="${arguments[0]}"
            echo action: $action >> ~/log/nix
            if [[ "$action" == \*:* ]]; then
                    completors+=("${action#\*:}")
                    # Don't shift $arguments when the action is repeatable
            else
                completors+=("${action#:}")
                arguments=(${arguments[*]:1})
                echo rest of arguments: ${arguments[*]} >> ~/log/nix
            fi
        fi
    done

    echo -- Finished parsing words: ${completors[*]} >> ~/log/nix

    local completor=${completors[$cword]}
    echo completor: $completor >> ~/log/nix

    case "$completor" in
        -\>*)
            state="${completor#->}"
            return 1
            ;;
        -*)
            ## Complete options
            echo excluded_options $excluded_options >> ~/log/nix
            COMPREPLY=($(compgen -W "${!options[*]}" -X "*($excluded_options)" -- "$cur"))
            return 0
            ;;
        *)
            "$completor" &> ~/log/nix
            return 0
    esac
}

function _nix_legacy () {
    local cur prev words cword
    # Setup current word, previous word, words and index of current word in
    # words (cword)
    _init_completion -n = || return

    echo number ${#words[*]} >> ~/log/nix
    echo cword $cword >> ~/log/nix
    echo ${words[*]} >> ~/log/nix

    local -a nix_boilerplate_opts=('--help' '--version')

    local nix_repair='--repair';

    local nix_search_path_args='-I:->file'

    # Misc Nix options accepted by nixos-rebuild
    local -a nix_common_nixos_rebuild=(
        {--verbose,-v} {--no-build-output,-Q}
        {--max-jobs,-j}':->empty' '--cores'
        '(--keep-going|-k)'{--keep-going,-k} {--keep-failed,-K}
        '--fallback' '--show-trace'
        '--option:->nixoption:->nixoptionvalue'
        ${nix_repair})

    # Used in: nix-build, nix-env, nix-instantiate, nix-shell
    local -a nix_common_opts=(
        ${nix_common_nixos_rebuild[*]}
            $_nix_search_path_args
            {--attr,-A}':->attr_path' {--expr,-E}
            '--arg:->empty:->empty' '--argstr:->empty:->empty'
            '--max-silent-time:->empty'
            '--timeout:->empty'
            '--readonly-mode'
            '--log-type:->log-type')

    local nix_dry_run='--dry-run'

    local -a nix_gc_common=(
        '(- --print* --delete)--print-roots'
            '(-|--print*|--delete)--print-live'
            '(-|--print*|--delete)--print-dead'
            '(-|--print*|--delete)--delete'
            )

    local state context
    local -a line
    local -A opt_args
    case "${words[0]}" in
        nix-build)
            local -a nix_build_opts=(
                '--drv-link:->empty' '--add-drv-link'
                '--no-out-link'
                {--out-link,-o}':->empty')
            _parse '*:->file' ${nix_common_opts[*]} \
                   ${nix_boilerplate_opts[*]} \
                   ${nix_build_opts[*]} && return 0
            ;;
        nix-shell)
            local -a nix_shell_opts=(
                '--command:->command'
                '--exclude:->regex'
                '--pure'
                '(--packages|-p|shell)'{--packages,-p}':->package_attr_path')
            _parse '*:->file' ${nix_common_opts[*]} \
                   + boiler \
                   ${nix_boilerplate_opts[*]} \
                   + shell \
                   ${nix_shell_opts[*]} && return 0
            ;;
        nix-env)
            local -a main_options=(
                {--install,-i} {--upgrade,-u} {--uninstall,-e} --set-flag {--query,-q} {--switch-profile,-S}
                --list-generations --delete-generations
                {--switch-generation,-G} --rollback)
            local ex_group="${main_options[*]}"
            ex_group="(${ex_group// /|})"
            local -a main_spec=(
                "$ex_group"{--install,-i} "$ex_group"{--upgrade,-u} "$ex_group"{--uninstall,-e}
                "$ex_group"--set-flag":->flag_name:->flag_value"
                "$ex_group"{--query,-q} "$ex_group"{--switch-profile,-S}
                "$ex_group"--list-generations
                "$ex_group"--delete-generations
                "$ex_group"{--switch-generation,-G} "$ex_group"--rollback
            )

            local -a nix_env_common_opts=(
                    '(--file|-f)'{--file,-f}':->file'
                    '(--profile|-p)'{--profile,-p}':->profile'
                    $nix_dry_run
                    '--system-filter[Only show derivations matching the specified platform]:system:_nix_systems')

            local -a nix_env_b=('(--prebuilt-only|-b)'{--prebuilt-only,-b})
            local nix_env_from_profile='--from-profile'

            # Workaround:
            # opt_args doesn't contain the first option
            # so can't detect stacked options like '-iA'
            local expect_attr_paths=false
            local word
            for word in ${words[*]:1}; do
                case $word in
                    --attr|-*([:alpha:])i*([:alpha:]))
                        expect_attr_paths=true
                        ;;
                esac
            done

            local -a command_options
            for word in ${words[*]:1}; do
                case "$word" in
                --install|-*([:alpha:])i*([:alpha:]))
                    command_options=(
                        ${nix_env_b[*]} $nix_env_from_profile
                        '(--preserve-installed|-P)'{--preserve-installed,-P}
                        '(--remove-all|-r)'{--remove-all,-r}
                        '(-A|--attr)'{-A,--attr}
                        '*:->nix_env_path')
                    break
                    ;;
                --upgrade|-*([:alpha:])u*([:alpha:]))
                    command_options=(
                        ${nix_env_b[*]}
                        ${nix_env_from_profile[*]}
                        '(-lt|-leq|-eq|--always)--lt'
                        '(-lt|-leq|-eq|--always)--leq'
                        '(-lt|-leq|-eq|--always)--eq'
                        '(-lt|-leq|-eq|--always)--always'
                        '*:->installed_packages')
                    break
                    ;;
                --uninstall|-*([:alpha:])e*([:alpha:]))
                    command_options=('*:->installed_packages')
                    break
                    ;;
                --set-flag)
                    break
                    ;;
                --query|-*([:alpha:])q*([:alpha:]))
                    command_options=(
                        ${nix_env_b[*]}
                        '(--available|-a)'{--available,-a}
                        '(--status|-s)'{--status,-s}
                        '(--attr-path|-P)'{--attr-path,-P}
                        '(--compare-versions|-c)'{--compare-versions,-c}
                        '--no-name' '--system' '--drv-path' '--out-path'
                        '--description' '--xml' '--json' '--meta')
                    break
                    ;;
                    --switch-profile|-*([:alpha:])S*([:alpha:]))
                        command_options=(':->nix_profile')
                        break
                        ;;
                    --delete-generations)
                        command_options=('*:->nix_generation')
                        break
                        ;;
                    --switch-generation|-[^-]#G[^-]#)
                        command_options=(':->nix_generation')
                        break
                        ;;

                esac
            done

            _parse ${command_options[*]} ${nix_env_common_opts[*]} \
                   ${nix_boilerplate_opts} ${main_spec[*]} && return 0

            case "$state" in
                nix_env_path)
                    local defexpr_path=""
                    echo file: "${opt_args[-f]}" "${opt_args[--file]}" >> ~/log/nix
                    if [[ "${opt_args[-f]}" || "${opt_args[--file]}" ]]; then
                        # Assumes you only provide one -f/--file
                        local file=${opt_args[-f]}${opt_args[--file]}
                        local abs_path=$(realpath $(_expand_tilde $file) 2>/dev/null)
                        if [[ -e "$abs_path" ]]; then
                           defexpr_path="import $abs_path {}"
                        fi
                    else
                        defexpr_path=$(_nix_gen_defexpr ~/.nix-defexpr)
                    fi
                    echo defexpr_path: $defexpr_path >> ~/log/nix
                    _nix_attr_paths "$defexpr_path"
                    ;;
                flag_name)
                    local -a _set_flag_attrs=(
                        'priority:Resolve package name conflicts'
                        'keep:Prevent package from being upgraded'
                        'active:Package is symlinked to profile'
                    )
                    # _describe -t commands "Package flag" _set_flag_attrs
                    ;;
                flag_value)
                    local flag_name=$words[$(($CURRENT - 1))]
                    case $flag_name in
                        priority)
                            # __message "Number, lower priority values denote a higher priority"
                            ;;
                        keep)
                            # _values "TF" true false
                            ;;
                        active)
                            # _values "TF" true false
                            ;;
                    esac
                    ;;
            esac
            ;;
        nix-store)
            local -a main_options=(
                {--realise,-r} '--gc' '--delete' {--query,-q} '--add'
                '--verify' '--verify-path' '--repair-path' '--dump'
                '--restore' '--export' '--import' '--optimise'
                {--read-log,-l} '--dump-db' '--load-db' '--print-env'
                '--query-failed-paths' '--clear-failed-paths')
            local ex_group="${main_options[*]}"
            ex_group="(${ex_group// /|})"
            local -a main_spec=(${main_options[*]/#/$ex_group})

            echo main spec: $main_spec >> ~/log/nix

            local -a command_options=()
            for word in ${words[*]:1}; do
                case "$word" in
                    --realise|-*([:alpha:])r*([:alpha:]))
                        command_options=(
                            ${nix_dry_run[*]}
                            '--ignore-unknown'
                            '*:->file')
                        break
                        ;;
                    --gc)
                        command_options=(
                            ${nix_gc_common[*]}
                            '--max-freed:->empty')
                        break
                        ;;
                    --delete)
                        command_options=('--ignore-liveness')
                        break
                        ;;
                    --query|-*([:alpha:])q*([:alpha:]))
                        local -a queries=(
                            '--outputs' {--requisites,-R} '--references'
                            '--referrers' '--referrers-closure'
                            '--deriver' '--graph' '--tree' '--binding'
                            '--hash' '--size' '--roots')
                        local query_group="${queries[*]}"
                        query_group="(${query_group// /|})"
                        local -a query_spec=(${queries[*]/#/$query_group})

                        local -a query_common=(
                            '(--use-output|-u)'{--use-output,-u}
                            '(--force-realise|-f)'{--force-realise,-f})

                        local -a requisite_options=()
                        for opt in ${words[*]:1}; do
                            case "$opt" in
                                --requisites|-*([:alpha:])R*([:alpha:]))
                                    requisite_options=('--include-outputs')
                                    ;;
                            esac
                        done
                        command_options=(${query_spec[*]} ${query_common[*]}
                                         {requisite_options[*]} "*:->file")
                        break
                        ;;
                    --verify)
                        command_options=('--check-contents' '--repair')
                        break
                        ;;
                    --dump-db|--load-db|--query-failed-paths)
                        # Nothing to complete
                        break
                        ;;
                    *)
                        command_options=('*:->file')
                        break
                        ;;
                esac
            done

            _parse ${command_options[*]} ${main_spec[*]} && return 0
            # TODO: Add main_spec completion if there's nothing else to do
            # probably needs to be done as a more general solution in _parse
            ;;
        nix-channel)
            # nix-channel handling
            _parse \
                '(-*)--add:->url:->channel_name' \
                '(-*)--remove:->nix_channels' \
                '(-*)--list' \
                '(-*)--update:->nix_channels'\
                '(-*)--rollback' && return 0

            case "$state" in
                nix_channels)
                    channels=($(nix-channel --list))
                    COMPREPLY=($(compgen -W "${channels[*]}" -- "$cur"))
                    return 0
                    ;;
            esac
            ;;
        nix-copy-closure)
            _parse \
                '(--from)--to' '(--to)--from' '--sign' '--gzip' \
                '--include-outputs' '(--use-substitutes -s)'{--use-substitutes,-s} \
                ':->user_at_host' ':->file' && return 0
            ;;
        nix-collect-garbage)
            _parse \
                '(--delete-old|-d)'{--delete-old,-d} \
                '--delete-older-than:->empty' \
                ${nix_dry_run[*]} && return 0
            ;;
        nix-hash)
            local -a ig=( '--to-base16' '--to-base32' )
            _parse \
                '(-*)--to-base16:->hash' \
                '(-*)--to-base32:->hash' \
                "(&ig)--flat" \
                "($ig)--base32" \
                "($ig)--truncate" \
                "($ig)--type:->hash_algo" \
                "*:->file" && return 0

            # TODO: Don't add file completion if we're using anything in $ig
            ;;
        nix-instantiate)
            _parse \
                ${nix_boilerplate_opts[*]} \
                ${nix_common_opts[*]} '--xml' '--json' '--add-root' \
                '--indirect' '--parse' '--eval' "--find-file:*:->file"\
                '--strict' '--read-write-mode' '*:->file' && return 0
            ;;
        nix-install-package)
            _parse \
                '--non-interactive' \
                '(--profile -p)'{--profile,-p}':->nix_profile' \
                '--set' \
                '--url:->url' \
                ':->file' && return 0
            # TODO: make --url and :->file mutually exclusive
            ;;
        nix-prefetch-url)
            _parse \
                '--type:->hash_algo' ':->url' ':->empty' && return 0
            ;;
        nix-push)
            _parse \
                '--dest:->directory' '(--none)--bzip2'\
                '(--bzip2)--none' '--force' '--link'\
                '(--manifest-path)--manifest'\
                '(--manifest)--manifest-path:->file'\
                '--url-prefix:->url'\
                '*:->file' && return 0
            ;;
        nixos-rebuild)
            local -a main_commands=(
                'switch' 'boot' 'test' 'build' 'dry-build'
                'dry-activate' 'build-vm' 'build-vm-with-bootloader')
            _parse \
                '--upgrade' '--install-grub' "--no-build-nix" \
                '--fast' '--rollback' \
                '(--profile-name -p)'{--profile-name,-p}':->nix_profile' \
                ':->main_commands' && return 0
            case "$state" in
                main_commands)
                    COMPREPLY=($(compgen -W "${main_commands[*]}" -- "$cur"))
                    return 0
                    ;;
            esac
            ;;
        nixos-install)
            _parse \
                $nix_search_path_args '--root:->directory'\
                '--show-trace' '--chroot' && return 0
            ;;
        nixos-generate-config)
            _parse '--no-filesystems' '--show-hardware-config' '--force'\
                   '--root:->directory' '--dir:->directory' && return 0
            ;;
        nixos-version)
            _parse '(-*)'{--hash,--revision} && return 0
            ;;
        nixos-container)
            local -a main_commands=(
                'list' 'create' 'destroy' 'start' 'stop' 'status' 'update'
                'login' 'root-login' 'run' 'show-ip' 'show-host-key')

            local container_name=':->container';
            local container_config='--config:->container_config';
            local -a main_options=()
            for word in ${words[*]:1}; do
                case "$word" in
                    create)
                        main_options=(
                            $container_name $container_config '--config-file:->file'
                            '--system-path:->file' '--ensure-unique-name' '--auto-start')
                        break
                        ;;
                    run)
                        main_options=($container_name)
                        break
                        ;;
                    update)
                        main_options=($container_name $container_config)
                        break
                        ;;
                    destroy|start|stop|status|login|root-login|show-ip|show-host-key)
                        main_options=($container_name)
                        break
                        ;;
                esac
            done
            _parse '--help' ':->main_commands' ${main_options[*]} && return 0
            case "$state" in
                main_commands)
                    COMPREPLY=($(compgen -W "${main_commands[*]}" -- "$cur"))
                    return 0
                    ;;
                container)
                    local -a containers=($(nixos-container list))
                    COMPREPLY=($(compgen -W "${containers[*]}" -- "$cur"))
                    return 0
                    ;;
            esac
            ;;
       nixos-build-vms)
           _parse '--show-trace' "--no-out-link" \
                  ':->nix_file' \
               && return 0
           ;;
    esac

    echo state: $state >> ~/log/nix
    echo line: ${line[*]} >> ~/log/nix
    echo opt_args: ${!opt_args[*]} ${opt_args[*]} >> ~/log/nix
    echo >> ~/log/nix

    # Handle completion of different types of arguments
    case "$state" in
        attr_path)
            local defexpr_path=""
            if [[ ${line[1]} ]]; then
                defexpr_path="import ${line[1]} {}"
            elif [[ -e shell.nix && $command_name == nix-shell ]]; then
                defexpr_path=shell.nix
            elif [[ -e default.nix ]]; then
                defexpr_path=default.nix
            fi
            echo defexpr: "$defexpr_path" >> ~/log/nix
            _nix_attr_paths "$defexpr_path"
            return 0
            ;;
        package_attr_path)
            _nix_attr_paths "import <nixpkgs>"
            return 0
            ;;
        file)
            COMPREPLY=($(compgen -f $cur))
            ;;
        directory)
            COMPREPLY=($(compgen -d $cur))
            ;;
        hash_algo)
            COMPREPLY=($(compgen -W "md5 sha1 sha256" -- "$cur"))
            return 0
            ;;
        *)
            echo $state not implemented yet >> ~/log/nix
            ;;

    esac
    return 1
}
# Set _nix_build to handle completion for nix-build
 complete -F _nix_legacy \
          nix-build nix-shell nix-env nix-store \
          nix-channel nix-copy-closure nix-collect-garbage \
          nix-hash nix-collect-garbage nix-instantiate \
          nix-install-package nix-prefetch-url nix-push \
          nixos-rebuild nixos-install nixos-version \
          nixos-container nixos-generate-config nixos-build-vms


function _nix () {
    local cur prev words cword
    # Setup current word, previous word, words and index of current word in
    # words (cword)
    _init_completion -n = || return

    local -a commands=(add-to-store build cat-nar cat-store copy copy-sigs dump-path edit eval hash-file hash-path log ls-nar ls-store optimise-store path-info repl run search show-config show-derivation sign-paths to-base16 to-base32 to-base64 verify why-depends
                           )

    local word
    for word in ${words[*]}; do
        case $word in
            run|build|eval)

                if [[ $cur == $word ]]; then
                    return 0
                fi

                local defexpr='{ '
                local -a nix_path=(${NIX_PATH/:/ })
                for i in ${nix_path[*]}; do
                    if [[ -z ${i/*=*/} ]]; then
                        # nixos-config isn't useful for completion
                        [[ ${i%=*} == nixos-config ]] && continue
                        defexpr+="${i/=/= import } {}; "
                    fi
                done
                local defexpr+=' }'

                _nix_attr_paths "$defexpr"
                return 0
                ;;
            *)
                # If word matches a command return
                if [[ "${commands[*]%$word}" != "${commands[*]}" ]]; then
                    return 0
                fi
        esac
    done

    COMPREPLY=( $(compgen -W "${commands[*]}" ${cur}))
}
complete -F _nix nix

# Generate nix code creating the default expression used by 'nix-env -iA'
_nix_gen_defexpr () {
    local -a result
    local -a queue=("$1")
    echo first argument: "$1" >> ~/log/nix
    while [[ ${#queue[*]} > 0 ]]; do
        echo queue ${#queue[*]} >> ~/log/nix
        local current="${queue[0]}"
        queue=(${queue[*]:1})
        if [[ -e "$current/default.nix" ]]; then
            result+=($current)
        else
            local -a children=($(echo "$current"/*))
            if [[ "$children" != *\* ]]; then
                queue+=(${children[*]})
            fi
        fi
    done

    local nix_expr="{ "
    for p in ${result[*]}; do
        nix_expr+="$(basename $p) = import $p {}; "
    done
    nix_expr+="}"

    echo $nix_expr
}

_expand_tilde()
{
    case "$1" in
        (\~)        echo "$HOME";;
        (\~/*)      echo "$HOME/${1#\~/}";;
        (\~[^/]*/*) local user=$(eval echo ${1%%/*})
                    echo "$user/${1#*/}";;
        (\~[^/]*)   eval echo ${1};;
        (*)         echo "$1";;
    esac
}
