function print () {
    return 0 # Comment out to turn on print debugging
    while [[ "$1" ]]; do
        echo  "$1" >> ~/log/nix
        shift
    done
}

function _nix_attr_names () {
    # prefix with 'top' as we let 'top = $defexpr' in NIX_FILE, where
    # 'builtins.attrNames $prefixed_path' is being run
    local prefixed_path=top${1:+.$1}
    local defexpr="$2"
    nix-instantiate --eval - <<NIX_FILE 2> /dev/null | tr '"[]' ' '
                let
                  top_gen = $defexpr;
                  # --file arguments can be a lambda producing a record too
                  top = if builtins.typeOf top_gen == "lambda" then top_gen {} else top_gen ;
                in
                  builtins.attrNames $prefixed_path
NIX_FILE
}

function _nix_attr_paths () {

    # The unnamed top context to look up attribute names
    local defexpr="$1"

    # The known valid part of the attribute path, eg. 'nixpkgs', if the
    # currently typed word is 'nixpkgs.mp'
    local attr_path=""
    if [[ -z ${cur/*.*/} ]]; then
        attr_path=${cur%.*}
    fi

    # Get all the attribute names in $attr_path
    local -a packages=($(_nix_attr_names "$attr_path" "$defexpr"))

    # Prefix all matches with "${attr_path}."
    local word_list=${packages[*]/#/${attr_path:+${attr_path}.}}
    # Don't insert space as we'll too often have to backspace and add a '.'
    compopt -o nospace
    ## Generate the completion list and match against the current word
    COMPREPLY=( $(compgen -W "${word_list}" ${cur}))
}


function _parse () {
    # Takes in `spec ...` and parses the command line using it

    ## Spec
    # :action -- A regular normal argument
    # *:action -- Repeating normal argument

    ## option spec
    # -o:action
    # [(pattern|pattern|...)][*]-f:action:[*]action
    # patterns to exclude from completion when option is typed

    ## action spec
    # ->string
    # set $state to 'string'
    # _function, function to run (isn't actually used though, so might be buggy)


    # [*]-f:action:action
    # [n]:action
    # :[*]action
    local -A options=()
    local -a arguments=("command")

    # Parse the spec
    local spec="$1"
    local -A groups
    local cur_group=""
    local split group excludes
    while [[ "$spec" ]]; do
        group=""

        excludes=""
        # check for an exclusion group
        # Strip it from $spec if found
        if [[ "$spec" == \(* ]]; then
            excludes=${spec%%\)*}
            excludes=${excludes:1}"#"
            spec="${spec#*\)}"
        fi
        case "$spec" in
            # *-\>*)
            #     # check if we're using -> syntax
            #     ;;
            +)
                shift
                cur_group="$1"
            ;;
            -*)
                # exclude the option from itself by default
                local -a split=(${spec/:/ })
                local flag=${split[0]}
                excludes=${flag}${excludes:+\|}${excludes:-\#}
                ;&
            \*-*)
                # Split on first :
                spec="${spec#\*}" # Strip possible star prefix
                local -a split=(${spec/:/ })
                local flag=${split[0]}
                if [[ "$cur_group" ]]; then
                    # Add the flag to the glob group
                    groups[$cur_group]+=${groups[$cur_group]:+|}$flag
                fi
                # Internal representation [group#][excludes#];
                options[$flag]="$excludes:${split[1]}"
                ;;
            :*|\*:*)
 #              echo Adding argument $spec
                arguments+=("$spec")
                ;;
        esac
        shift
        spec="$1"
    done
    print  "    --**--" "-- Finished parsing spec"
    print  "arguments:" "${arguments[*]}"
    print "options" "${!options[*]}" >> ~/log/nix
    # print  groups: ${!groups[*]} ${groups[*]} 


    print  "-- Parse words"
    # Use the parsed spec to handle the input
    # opt_arg queue
    local -a opt_queue=()
    local -a used_options=()
    local current_option=""
    local excluded_options=""
    # The list of completors corresponding to each word in words
    local completors=()
    line=()

    local word=""
    opt_args=()
    for word in ${words[*]} ""; do
        if [[ "${opt_queue[*]}" ]]; then
            # Consume an option argument
            print "consume option queue: $word ${opt_queue[0]}"
            line+=("$word")
            local separator=${opt_args["$current_option"]:+:}
            opt_args["$current_option"]+=$separator"${word//:/\\:}"

            local action="${opt_queue[0]}"
            if [[ "$action" == \** ]]; then
                completors+=(${action#\*})
            else
                completors+=(${action})
                opt_queue=(${opt_queue[*]:1})
            fi
        elif [[ "$word" == --* ]]; then
            # Long option
            print "Consume an option: $word ${options["$word"]}"
            completors+=("$word")
            local -a actions=(${options["$word"]//:/ })
            # Check if actions contains an exclusion pattern
            if [[ ${actions[0]} == *\# ]]; then
                local prefix="${excluded_options:+|}"
                excluded_options+="$prefix${actions[0]:0:-1}"
                print "$word's exclusion group:" "$prefix${actions[0]:0:-1}"
                actions=(${actions[*]:1})
            fi
            if [[ "${actions[*]}" ]]; then
                current_option="$word"
                # Add to the option argument queue
                print  "option arguments: ${actions[*]}"
                opt_queue=(${actions[*]})
                print  "option queue: ${opt_queue[*]}"
            fi
        elif [[ "$word" == -* ]]; then
            # Short option, possibly stacked
            print "Consume short options: $word ${options["$word"]}"
            local flags=${word#-}
            completors+=("$word")
            while [[ "$flags" ]]; do
                local flag="-${flags:0:1}"
                local -a actions=(${options["$flag"]//:/ })
                # Check if actions contains an exclusion pattern
                if [[ ${actions[0]} == *\# ]]; then
                    local prefix="${excluded_options:+|}"
                    excluded_options+="$prefix${actions[0]:0:-1}"
                    print "$flag's exclusion group:" "$prefix${actions[0]:0:-1}" 
                    actions=(${actions[*]:1})
                fi
                if [[ "${actions[*]}" ]]; then
                    current_option="$flag"
                    # Add to the option argument queue
                    print  "option arguments: ${actions[*]}"
                    opt_queue=(${actions[*]})
                    print  "option queue: ${opt_queue[*]}"
                fi
                flags="${flags:1}"
            done
        else
            # Consume a regular argument
            print  "Consume a regular argument: $word"
            line+=("$word")
            print  "Adding completor: ${arguments[0]}"
            # Always add argument completors, even if empty
            local action="${arguments[0]}"
            print actio"n: $action"
            if [[ "$action" == \*:* ]]; then
                    completors+=("${action#\*:}")
                    # Don't shift $arguments when the action is repeatable
            else
                completors+=("${action#:}")
                arguments=(${arguments[*]:1})
                print  "rest of arguments: ${arguments[*]}"
            fi
        fi
    done

    print  "-- Finished parsing words: ${completors[*]}"

    local completor=${completors[$cword]}
    print  "completor: $completor" 

    case "$completor" in
        -\>*)
            state="${completor#->}"
            return 1
            ;;
        -*)
            ## Complete options
            # print  excluded_options before: $excluded_options 
            # local g
            # for g in ${!groups[*]}; do
            #     # echo group: $g, "${groups[$g]}"
            #     # resolve groups to globs
            #     excluded_options="${excluded_options//$g/${groups[$g]}}"
            # done
            print  "excluded_options $excluded_options"
            COMPREPLY=($(compgen -W "${!options[*]}" -X "*($excluded_options)" -- "$cur"))
            return 0
            ;;
        _*)
            $completor
            return 0
            ;;
        "")
            COMPREPLY=($(compgen -W "${!options[*]}" -X "*($excluded_options)" -- "$cur"))
            return 0
            ;;
    esac
}

# Completions for all nix-commands except for nix
function _nix_legacy () {
    local cur prev words cword
    # Setup current word, previous word, words and index of current word in
    # words (cword)
    _init_completion -n = || return

    print  "command line: ${words[*]}"
    print  "number ${#words[*]}"
    print  "cword $cword"

    local -a nix_boilerplate_opts=('--help' '--version')

    local nix_repair='--repair';

    local nix_search_path_args='-I:->file'

    # Misc Nix options accepted by nixos-rebuild
    local -a nix_common_nixos_rebuild=(
        {--verbose,-v} {--no-build-output,-Q}
        {--max-jobs,-j}':->empty' '--cores'
        '(--keep-going|-k)'{--keep-going,-k} {--keep-failed,-K}
        '--fallback' '--show-trace'
        '--option:->nixoption:->nixoptionvalue'
        ${nix_repair})

    # Used in: nix-build, nix-env, nix-instantiate, nix-shell
    local -a nix_common_opts=(
        ${nix_common_nixos_rebuild[*]}
            ${nix_search_path_args}
            "*"{--attr,-A}':->attr_path' {--expr,-E}
            '--arg:->empty:->empty' '--argstr:->empty:->empty'
            '--max-silent-time:->empty'
            '--timeout:->empty'
            '--readonly-mode'
            '--log-type:->log-type')

    local nix_dry_run='--dry-run'

    local -a nix_gc_common=(
        '(- --print* --delete)--print-roots'
            '(-|--print*|--delete)--print-live'
            '(-|--print*|--delete)--print-dead'
            '(-|--print*|--delete)--delete'
            )

    local state context
    local -a line
    local -A opt_args
    case "${words[0]}" in
        nix-build)
            local -a nix_build_opts=(
                '--drv-link:->empty' '--add-drv-link'
                '--no-out-link'
                {--out-link,-o}':->empty')
            _parse '*:->file' ${nix_common_opts[*]} \
                   ${nix_boilerplate_opts[*]} \
                   ${nix_build_opts[*]} && return 0
            ;;
        nix-shell)
            local -a nix_shell_opts=(
                '--command:->command'
                '--exclude:->regex'
                '--pure'
                # nix-shell only takes one -A, so override the default
                "(--attr|-A)"{--attr,-A}':->attr_path'
                '(--packages|-p|shell)'{--packages,-p}':*->package_attr_path')
            _parse '*:->file' ${nix_common_opts[*]} \
                   + boiler \
                   ${nix_boilerplate_opts[*]} \
                   + shell \
                   ${nix_shell_opts[*]} && return 0
            ;;
        nix-env)
            local -a main_options=(
                {--install,-i} {--upgrade,-u} {--uninstall,-e} --set-flag
                {--query,-q} {--switch-profile,-S}
                --list-generations --delete-generations
                {--switch-generation,-G} --rollback)
            local ex_group="${main_options[*]}"
            ex_group="(${ex_group// /|})"
            local -a main_spec=(
                "$ex_group"{--install,-i} "$ex_group"{--upgrade,-u}
                "$ex_group"{--uninstall,-e}
                "$ex_group"--set-flag":->flag_name:->flag_value"
                "$ex_group"{--query,-q} "$ex_group"{--switch-profile,-S}
                "$ex_group"--list-generations
                "$ex_group"--delete-generations
                "$ex_group"{--switch-generation,-G} "$ex_group"--rollback
            )

            local -a nix_env_common_opts=(
                    '(--file|-f)'{--file,-f}':->file'
                    '(--profile|-p)'{--profile,-p}':->profile'
                    $nix_dry_run
                    '--system-filter[Only show derivations matching the specified platform]:system:_nix_systems')

            local -a nix_env_b=('(--prebuilt-only|-b)'{--prebuilt-only,-b})
            local nix_env_from_profile='--from-profile'

            local -a command_options
            for word in ${words[*]:1}; do
                case "$word" in
                --install|-*([a-zA-Z])i*([a-zA-Z]))
                    command_options=(
                        ${nix_env_b[*]} $nix_env_from_profile
                        '(--preserve-installed|-P)'{--preserve-installed,-P}
                        '(--remove-all|-r)'{--remove-all,-r}
                        '(-A|--attr)'{-A,--attr}
                        '*:->nix_env_path')
                    break
                    ;;
                --upgrade|-*([a-zA-Z])u*([a-zA-Z]))
                    command_options=(
                        ${nix_env_b[*]}
                        ${nix_env_from_profile[*]}
                        '(-lt|-leq|-eq|--always)--lt'
                        '(-lt|-leq|-eq|--always)--leq'
                        '(-lt|-leq|-eq|--always)--eq'
                        '(-lt|-leq|-eq|--always)--always'
                        '*:->installed_packages')
                    break
                    ;;
                --uninstall|-*([a-zA-Z])e*([a-zA-Z]))
                    command_options=('*:->installed_packages')
                    break
                    ;;
                --set-flag)
                    break
                    ;;
                --query|-*([a-zA-Z])q*([a-zA-Z]))
                    command_options=(
                        ${nix_env_b[*]}
                        '(--available|-a)'{--available,-a}
                        '(--status|-s)'{--status,-s}
                        '(--attr-path|-P)'{--attr-path,-P}
                        '(--compare-versions|-c)'{--compare-versions,-c}
                        '--no-name' '--system' '--drv-path' '--out-path'
                        '--description' '--xml' '--json' '--meta')
                    break
                    ;;
                    --switch-profile|-*([a-zA-Z])S*([a-zA-Z]))
                        command_options=(':->nix_profile')
                        break
                        ;;
                    --delete-generations)
                        command_options=('*:->nix_generation')
                        break
                        ;;
                    --switch-generation|-[^-]#G[^-]#)
                        command_options=(':->nix_generation')
                        break
                        ;;

                esac
            done

            _parse ${nix_env_common_opts[*]} ${command_options[*]} \
                   ${nix_boilerplate_opts} ${main_spec[*]} && return 0

            case "$state" in
                nix_env_path)
                    # Workaround:
                    # opt_args doesn't contain empty options
                    # so can't detect stacked options like '-iA'
                    local expect_attr_paths=false
                    for word in ${words[*]:1}; do
                        case $word in
                            --attr|-*([a-zA-Z])A*([a-zA-Z]))
                                expect_attr_paths=true
                            ;;
                        esac
                    done
                    if [[ "$expect_attr_paths" == "false" ]]; then
                        # Don't try to complete names if -A isn't present
                        return 0
                    fi

                    local defexpr_path=""
                    if [[ "${opt_args[-f]}" || "${opt_args[--file]}" ]]; then
                        # Assumes you only provide one -f/--file
                        local file=${opt_args[-f]}${opt_args[--file]}
                        local abs_path=$(realpath $(_expand_tilde $file) 2>/dev/null)
                        if [[ -e "$abs_path" ]]; then
                           defexpr_path="import $abs_path {}"
                        fi
                    else
                        defexpr_path=$(_nix_gen_defexpr ~/.nix-defexpr)
                    fi
                    print  "defexpr_path: $defexpr_path"
                    _nix_attr_paths "$defexpr_path"
                    ;;
                flag_name)
                    COMPREPLY=($(compgen -W "priority keep active" -- "$cur"))
                    ;;
                flag_value)
                    local flag_name=$prev
                    case $flag_name in
                        priority)
                            return 0
                            ;;
                        keep|active)
                            COMPREPLY=($(compgen -W "true false" -- "$cur"))
                            return 0
                            ;;
                    esac
                    ;;
            esac
            ;;
        nix-store)
            local -a main_options=(
                {--realise,-r} '--gc' '--delete' {--query,-q} '--add'
                '--verify' '--verify-path' '--repair-path' '--dump'
                '--restore' '--export' '--import' '--optimise'
                {--read-log,-l} '--dump-db' '--load-db' '--print-env'
                '--query-failed-paths' '--clear-failed-paths')
            local ex_group="${main_options[*]}"
            ex_group="(${ex_group// /|})"
            local -a main_spec=(${main_options[*]/#/$ex_group})

            local -a command_options=()
            for word in ${words[*]:1}; do
                case "$word" in
                    --realise|-*([a-zA-Z])r*([a-zA-Z]))
                        command_options=(
                            ${nix_dry_run[*]}
                            '--ignore-unknown'
                            '*:->file')
                        break
                        ;;
                    --gc)
                        command_options=(
                            ${nix_gc_common[*]}
                            '--max-freed:->empty')
                        break
                        ;;
                    --delete)
                        command_options=('--ignore-liveness')
                        break
                        ;;
                    --query|-*([a-zA-Z])q*([a-zA-Z]))
                        local -a queries=(
                            '--outputs' {--requisites,-R} '--references'
                            '--referrers' '--referrers-closure'
                            '--deriver' '--graph' '--tree' '--binding'
                            '--hash' '--size' '--roots')
                        local query_group="${queries[*]}"
                        query_group="(${query_group// /|})"
                        local -a query_spec=(${queries[*]/#/$query_group})

                        local -a query_common=(
                            '(--use-output|-u)'{--use-output,-u}
                            '(--force-realise|-f)'{--force-realise,-f})

                        local -a requisite_options=()
                        for opt in ${words[*]:1}; do
                            case "$opt" in
                                --requisites|-*([a-zA-Z])R*([a-zA-Z]))
                                    requisite_options=('--include-outputs')
                                    ;;
                            esac
                        done
                        command_options=(${query_spec[*]} ${query_common[*]}
                                         {requisite_options[*]} "*:->file")
                        break
                        ;;
                    --verify)
                        command_options=('--check-contents' '--repair')
                        break
                        ;;
                    --dump-db|--load-db|--query-failed-paths)
                        # Nothing to complete
                        break
                        ;;
                    *)
                        command_options=('*:->file')
                        break
                        ;;
                esac
            done

            _parse ${command_options[*]} ${main_spec[*]} && return 0
            ;;
        nix-channel)
            # nix-channel handling
            _parse \
                '(-*)--add:->url:->channel_name' \
                '(-*)--remove:->nix_channels' \
                '(-*)--list' \
                '(-*)--update:->nix_channels'\
                '(-*)--rollback' && return 0

            case "$state" in
                nix_channels)
                    channels=($(nix-channel --list))
                    COMPREPLY=($(compgen -W "${channels[*]}" -- "$cur"))
                    return 0
                    ;;
            esac
            ;;
        nix-copy-closure)
            _parse \
                '(--from)--to' '(--to)--from' '--sign' '--gzip' \
                '--include-outputs' '(--use-substitutes -s)'{--use-substitutes,-s} \
                ':_user_at_host' '*:->file' && return 0
            ;;
        nix-collect-garbage)
            _parse \
                '(--delete-old|-d)'{--delete-old,-d} \
                '--delete-older-than:->empty' \
                ${nix_dry_run[*]} && return 0
            ;;
        nix-hash)
            local ig='--to-base16|--to-base32'
            _parse \
                '(-*)--to-base16:->hash' \
                '(-*)--to-base32:->hash' \
                "($ig)--flat" \
                "($ig)--base32" \
                "($ig)--truncate" \
                "($ig)--type:->hash_algo" \
                "*:->file" && return 0

            # TODO: Don't add file completion if we're using anything in $ig
            ;;
        nix-instantiate)
            _parse \
                ${nix_boilerplate_opts[*]} \
                ${nix_common_opts[*]} '--xml' '--json' '--add-root' \
                '--indirect' '--parse' '--eval' "--find-file:*->file"\
                '--strict' '--read-write-mode' '*:->file' && return 0
            ;;
        nix-install-package)
            _parse \
                '--non-interactive' \
                '(--profile|-p)'{--profile,-p}':->nix_profile' \
                '--set' \
                '--url:->url' \
                ':->file' && return 0
            # TODO: make --url and :->file mutually exclusive
            ;;
        nix-prefetch-url)
            _parse \
                '--type:->hash_algo' ':->url' ':->empty' && return 0
            ;;
        nix-push)
            _parse \
                '--dest:->directory' '(--none)--bzip2'\
                '(--bzip2)--none' '--force' '--link'\
                '(--manifest-path)--manifest'\
                '(--manifest)--manifest-path:->file'\
                '--url-prefix:->url'\
                '*:->file' && return 0
            ;;
        nixos-rebuild)
            local -a main_commands=(
                'switch' 'boot' 'test' 'build' 'dry-build'
                'dry-activate' 'build-vm' 'build-vm-with-bootloader')
            _parse \
                '--upgrade' '--install-grub' "--no-build-nix"             \
                '--fast' '--rollback'                                     \
                '(--profile-name -p)'{--profile-name,-p}':->nix_profile'  \
                ':->main_commands' && return 0
            case "$state" in
                main_commands)
                    COMPREPLY=($(compgen -W "${main_commands[*]}" -- "$cur"))
                    return 0
                    ;;
            esac
            ;;
        nixos-install)
            _parse \
                $nix_search_path_args '--root:->directory'\
                '--show-trace' '--chroot' && return 0
            ;;
        nixos-generate-config)
            _parse '--no-filesystems' '--show-hardware-config' '--force'\
                   '--root:->directory' '--dir:->directory' && return 0
            ;;
        nixos-version)
            _parse '(-*)'{--hash,--revision} && return 0
            ;;
        nixos-container)
            local -a main_commands=(
                'list' 'create' 'destroy' 'start' 'stop' 'status' 'update'
                'login' 'root-login' 'run' 'show-ip' 'show-host-key')

            local container_name=':->container';
            local container_config='--config:->container_config';
            local -a main_options=()
            for word in ${words[*]:1}; do
                case "$word" in
                    create)
                        main_options=(
                            $container_name $container_config '--config-file:->file'
                            '--system-path:->file' '--ensure-unique-name'
                            '--auto-start')
                        break
                        ;;
                    run)
                        main_options=($container_name)
                        break
                        ;;
                    update)
                        main_options=($container_name $container_config)
                        break
                        ;;
                    destroy|start|stop|status|login|root-login|show-ip|show-host-key)
                        main_options=($container_name)
                        break
                        ;;
                esac
            done
            _parse '--help' ':->main_commands' ${main_options[*]} && return 0
            case "$state" in
                main_commands)
                    COMPREPLY=($(compgen -W "${main_commands[*]}" -- "$cur"))
                    return 0
                    ;;
                container)
                    local -a containers=($(nixos-container list))
                    COMPREPLY=($(compgen -W "${containers[*]}" -- "$cur"))
                    return 0
                    ;;
            esac
            ;;
       nixos-build-vms)
           _parse '--show-trace' "--no-out-link" \
                  ':->nix_file' \
               && return 0
           ;;
    esac

    print  "state: $state"
    print  "line: ${line[*]}"
    print  "opt_args: ${!opt_args[*]} ${opt_args[*]}"

    # Handle completion of different types of arguments
    case "$state" in
        attr_path)
            local defexpr_path=""
            if [[ ${line[1]} ]]; then
                defexpr_path="import ${line[1]} {}"
            elif [[ -e shell.nix && "${words[0]}" == nix-shell ]]; then
                defexpr_path="import $(realpath shell.nix) {}"
            elif [[ -e default.nix ]]; then
                defexpr_path="import $(realpath default.nix) {}"
            fi
            print  "defexpr: $defexpr_path" 
            _nix_attr_paths "$defexpr_path"
            return 0
            ;;
        package_attr_path)
            _nix_attr_paths "import <nixpkgs>"
            return 0
            ;;
        file|nix_file)
            COMPREPLY=($(compgen -f $cur))
            ;;
        directory)
            COMPREPLY=($(compgen -d $cur))
            ;;
        hash_algo)
            COMPREPLY=($(compgen -W "md5 sha1 sha256" -- "$cur"))
            return 0
            ;;
        *)
            print  "$state not implemented yet"
            ;;

    esac
    return 1
}
# Set _nix_build to handle completion for nix-build
 complete -F _nix_legacy \
          nix-build nix-shell nix-env nix-store \
          nix-channel nix-copy-closure nix-collect-garbage \
          nix-hash nix-collect-garbage nix-instantiate \
          nix-install-package nix-prefetch-url nix-push \
          nixos-rebuild nixos-install nixos-version \
          nixos-container nixos-generate-config nixos-build-vms


# nix-1.12 nix command
function _nix () {
    local cur prev words cword
    # Setup current word, previous word, words and index of current word in
    # words (cword)
    _init_completion -n = || return

    local state context
    local -a line
    local -A opt_args

    print " --***-- nix"

    local -a common_options
    common_options=("(--debug)"--debug "(-h|--help)"{-h,--help}
                    "(--help-config)"--help-config
                    "*--builders:->machine" "--store:->option-STORE-URI"
                    "*--option:->nixoption:->nixoptionvalue"
                    "(--quiet)--quiet" "*{-v,--verbose}"
                    "(--version)"--version)

    # Extract the commands with descriptions
    # like ('command:some description' 'run:run some stuff')
    local -a main_commands
    main_commands=(
        $(nix --help | sed -E \
                           -e '/^Available commands/,/^$/!d' \
                           -e '/^Available commands/d' \
                           -e '/^$/d' \
                           -e 's=^ +([0-9a-z-]*) +(.*)$=\1='))
    # Add commands to an associative array for easy lookup
    local -A command_lookup
    local main_command
    for main_command in ${main_commands[*]}; do
        command_lookup[$main_command]=1
    done

    local -a command_options=()
    local -a command_arguments=()
    # Setup the correct command_arguments and command_options depending on which
    # command we've typed
    local word
    for word in ${words[*]:1}; do

        # Check if we're in a valid command
        if [[ "${command_lookup[$word]}" == 1 ]]; then
            # Extract an array describing the possible arguments to the
            # command eg. (NAR PATH) for cat-nar or (INSTALLABLES) for run
            local -a args=(
                $(nix $word --help | sed -E \
                                         -e '2,$d' \
                                         -e 's=^Usage.*<FLAGS>==' \
                                         -e 's=\.|\?|<|>==g'))
            # And add the corresponding completors
            local arg
            for arg in ${args[*]}; do
                local plural=""
                [[ "$arg" == *S ]] && plural="*"
                command_arguments+=("${plural}:->arg-$arg")
            done

            # Extract the lines containing the option descriptions
            # Strip out the human descriptions
            local -a option_descriptions
            option_descriptions=(
                $(nix $word --help | sed -E \
                                         -e '/^Flags:/,/^$/!d' \
                                         -e "/^Flags:/d" \
                                         -e 's/(.*)  .*/\1/' \
                                         -e 's/ //g' \
                                         -e '/^$/d'))

            local option option_spec
            for option_spec in ${option_descriptions[*]}; do

                # Extract the options by stripping everything starting at '<'
                # (and ',')
                # local flags="${option_spec##<*/}"
                # local -a option_group=(${flags/,/ })

                local -a option_group=($(echo "$option_spec" \
                                             | sed -E \
                                                   -e 's=,= =' \
                                                   -e 's=<.*=='))
                # Extract any arguments, by stripping the options (and <|>)
                local -a option_args=(
                    $(echo "$option_spec" | sed -E \
                                                -e 's=[^<]*<==' \
                                                -e 's=<|>= =g'))

                local ACTIONS=""
                for arg in ${option_args[*]}; do
                    local plural=""
                    [[ "$arg" == *S ]] && plural="*"
                    ACTIONS+=":${plural}->option-$arg"
                done

                for option in ${option_group[*]}; do
                    # Handle `run --keep/--unset` manually as they can be repeated
                    if [[ "$word" == run && "$option" == @(-k|--keep|-u|--unset) ]]; then
                        command_options+=("*${option}:->PARAMS")
                    elif [[ "$option" == @(-I|--include|--arg|--argstr) ]]; then
                        # Repeatable options
                        command_options+=("*${option}"$ACTIONS)
                    else
                        # Default to mutually exclusive non-repeatable options
                        local exclusions="${option_group[*]}"
                        command_options+=("(${exclusions// /|})"$option$ACTIONS)
                    fi
                done
            done

            break
        fi
    done

    print "command arguments: "

    _parse ':->main_command' \
           ${command_arguments[*]} \
           ${common_options[*]} \
           ${command_options[*]} && return 0

    # Handle argument completion based on the resulting state
    case "$state" in
        main_command)
            COMPREPLY=($(compgen -W "${main_commands[*]}" -- "$cur"))
            return 0
            ;;
        arg-@(INSTALLABLES|INSTALLABLE|PACKAGE|DEPENDENCY))

            if [[ "$cur" == @("./"*|/*|\~*) ]]; then
                # Complete files and return if we're entering files with
                # absolute file syntax that nix will understand
                COMPREPLY=($(compgen -f -- $cur))
                return 0
            fi

            local defexpr=""
            if [[ "${opt_args[-f]}" || "${opt_args[--file]}" ]]; then
                # Assumes you only provide one -f/--file
                local file=${opt_args[-f]}${opt_args[--file]}
                local abs_path=$(realpath $(_expand_tilde $file) 2>/dev/null)
                if [[ -e "$abs_path" ]]; then
                    defexpr="import $abs_path {}"
                fi
            else
                # Fall back to completing available channels in the NIX_PATH

                # Extract the channels from NIX_PATH and -I/--include
                local -a channels=(${NIX_PATH[*]//:/ })
                # Add -I/--include afterwards, so they will shadow the NIX_PATH
                channels+=(${opt_args[-I]//:/ })
                channels+=(${opt_args[--include]//:/ })

                local -A path_map
                local channel name nix_path
                for channel in ${channels[*]}; do
                    name=${channel%%=*}
                    nix_path=${channel#*=}
                    if [[ "$name" != "$channel" ]]; then
                        # Only add paths with a name, not sure how they work
                        path_map[$name]=$nix_path
                    fi
                done

                defexpr=$'{ '
                for name in ${!path_map[*]}; do
                    # nixos-config isn't useful or possible to complete
                    [[ "$name" == nixos-config ]] && continue
                    defexpr+="$name = import ${path_map[$name]} {}; "
                done
                defexpr+=' }'
            fi
            _nix_attr_paths "$defexpr"
            return 0
            ;;
        arg-@(PATH|PATHS|FILES|NAR))
            COMPREPLY=($(compgen -f -- $cur))
            return
            ;;
        arg-REGEX)
            return
            ;;
        arg-STRINGS)
            return
            ;;
        option-NAME)
            return
            ;;
        option-EXPR)
            return
            ;;
        option-STRING)
            return
            ;;
        option-STORE-URI)
            ## Not sure how to present alternatives here
            COMPREPLY=($(compgen -d -- $cur))
            return
            ;;
        option-COMMAND)
            COMPREPLY=($(compgen -c -- $cur))
            ;;
        option-@(FILE|FILES))
            COMPREPLY=($(compgen -f -- $cur))
            ;;
        option-TYPE)
            COMPREPLY=($(compgen -W "md5 sha1 sha256" -- "$cur"))
            return
            ;;
        option-PATH)
            return
            ;;
        nixoption)
            local -a nix_options
            nix_options=($(nix --help-config | sed -E \
                                                   -e '/^$/,/^$/!d' \
                                                   -e '/^$/d' \
                                                   -e 's=^ +([0-9a-z-]*) +(.*)$=\1='))
            COMPREPLY=($(compgen -W "${nix_options[*]}" -- $cur))
            ;;
        *)
            print "$state not implemented"
    esac
}
complete -F _nix nix

# Generate nix code creating the default expression used by 'nix-env -iA'
_nix_gen_defexpr () {
    local -a result
    local -a queue=("$1")
    while [[ ${#queue[*]} > 0 ]]; do
        local current="${queue[0]}"
        queue=(${queue[*]:1})
        if [[ -e "$current/default.nix" ]]; then
            result+=($current)
        else
            local -a children=($(echo "$current"/*))
            if [[ "$children" != *\* ]]; then
                queue+=(${children[*]})
            fi
        fi
    done

    local nix_expr="{ "
    for p in ${result[*]}; do
        nix_expr+="$(basename $p) = import $p {}; "
    done
    nix_expr+="}"

    echo $nix_expr
}

_expand_tilde()
{
    case "$1" in
        (\~)        echo "$HOME";;
        (\~/*)      echo "$HOME/${1#\~/}";;
        (\~[^/]*/*) local user=$(eval echo ${1%%/*})
                    echo "$user/${1#*/}";;
        (\~[^/]*)   eval echo ${1};;
        (*)         echo "$1";;
    esac
}
